#include <cstddef>
#include <utility>
#include <iostream>

namespace fwd_list {
    template <typename T>
    class Node {
    public:
        Node* next;
        T* value;

        explicit Node(Node* next) :
                next(next),
                value(nullptr)
        {}

        Node(Node* next, const T& elem) :
                next(next),
                value(nullptr)
        {
            value = new T(elem);
        }

        Node(Node* next, T* ptr) :
            next(next),
            value(ptr)
        { }
    };

    template <typename T>
    class ListIterator {
    public:
        explicit ListIterator(Node<T>* it) : cur(it)
        { }

        ListIterator& operator++() {
            cur = cur->next;
            return *this;
        }

        const ListIterator& operator++(int) {
            auto copy = ListIterator(*this);
            ++(*this);
            return copy;
        }

        const T& operator* () const {
            return *cur->value;
        }

        T& operator* () {
            return *cur->value;
        }

        T* & ptr_value () {
            return cur->value;
        }

        bool operator==(const ListIterator& oth) const {
            return cur == oth.cur;
        }

        bool operator!=(const ListIterator& oth) const {
            return cur != oth.cur;
        }

    private:
        Node<T>* cur;
    };
}  // namespace fwd_list

template <typename T>
class List {
public:
    List() {
        tail = new fwd_list::Node<T>(nullptr);
        head = new fwd_list::Node<T>(tail);
    }

    ~List() {
        NodeClear(head);
    }

    void push_front(const T& x) {
        auto* ext = new fwd_list::Node<T>(head->next, x);
        head->next = ext;
    }

    fwd_list::ListIterator<T> begin() {
        return fwd_list::ListIterator<T>(head->next);
    }

    fwd_list::ListIterator<T> end() {
        return fwd_list::ListIterator<T>(tail);
    }

    fwd_list::Node<T>*& ptr_head () {
        return head;
    }

    fwd_list::Node<T>*& ptr_tail () {
        return tail;
    }

private:
    // Delete all nodes from the list.
    void NodeClear(fwd_list::Node<T>* cur) {
        if (cur != nullptr) {
            NodeClear(cur->next);
        }
        delete cur;
    }

    fwd_list::Node<T>* head;
    fwd_list::Node<T>* tail;
};

template <typename T>
void sort(const fwd_list::ListIterator<T>& begin, const fwd_list::ListIterator<T>& end) {
    size_t n = 0;
    for (auto it = begin; it != end; ++it) {
        ++n;
    }

    if (n < 2) return;

    auto mid = begin;
    size_t sz;
    for (sz = 0; 2*sz < n; ++sz) {
        ++mid;
    }

    sort(begin, mid);
    sort(mid, end);

    List<T> s;
    auto cur = s.ptr_head();
    auto it1 = begin;
    auto it2 = mid;

    for (; it1 != mid && it2 != end;) {
        if (*it1 > *it2) {
            cur->next = new fwd_list::Node<T>(nullptr, it2.ptr_value());
            cur = cur->next;
            ++it2;
        } else {
            cur->next = new fwd_list::Node<T>(nullptr, it1.ptr_value());
            cur = cur->next;
            ++it1;
        }
    }

    for (; it1 != mid; ++it1) {
        cur->next = new fwd_list::Node<T>(nullptr, it1.ptr_value());
        cur = cur->next;
    }

    for (; it2 != end; ++it2) {
        cur->next = new fwd_list::Node<T>(nullptr, it2.ptr_value());
        cur = cur->next;
    }
    cur->next = s.ptr_tail();

    it1 = begin;
    it2 = s.begin();
    while (it1 != end) {
        it1.ptr_value() = it2.ptr_value();
        ++it1;
        ++it2;
    }
}

int main() {
    List<int> lst;
    size_t n;
    std::cin >> n;
    for (size_t i = 0; i != n; ++i) {
        int x;
        std::cin >> x;
        lst.push_front(x);
    }

    sort(lst.begin(), lst.end());
    for (auto elem : lst) {
        std::cout << elem << ' ';
    }
    std::cout << '\n';
}
