#include <cstddef>
#include <utility>

#include <iostream>

namespace odl {
    template <typename T>
    class Node {
    public:
        Node* next;
        T value;

        Node(Node* next) :
                next(next),
                value()
        {}

        Node(Node* next, const T& elem) :
                next(next),
                value(elem)
        {}
    };

    template <typename T>
    class ListIterator {
    public:
        ListIterator(Node<T>* it) : cur(it)
        { }

        ListIterator& operator++() {
            cur = cur->next;
            return *this;
        }

        ListIterator operator++(int) {
            auto copy = ListIterator(*this);
            cur = cur->next;
            return copy;
        }

        const T& operator* () const {
            return cur->value;
        }

        T& operator* () {
            return cur->value;
        }

        bool operator==(const ListIterator& oth) const {
            return cur == oth.cur;
        }

        bool operator!=(const ListIterator& oth) const {
            return cur != oth.cur;
        }

    private:
        Node<T>* cur;
    };
}  // namespace odl

template <typename T>
class List {
public:
    List() {
        start = new odl::Node<T>(finish);
        last = &start;
        finish = new odl::Node<T>(nullptr);
        size_val = 0;
    }

    ~List() {
        NodeDelete(start);
    }

    void push_back(const T& x) {
        auto* ext = new odl::Node<T>(finish, x);
        (*last)->next = ext;
        last = &(*last)->next;
        ++size_val;
    }

    size_t size() const {
        return size_val;
    }

    odl::ListIterator<T> begin() {
        return {start->next};
    }

    odl::ListIterator<T> end() {
        return {finish};
    }

private:
    void NodeDelete(odl::Node<T>*& cur) {
        if (cur != nullptr) {
            NodeDelete(cur->next);
        }
        delete cur;
    }

    odl::Node<T>* start;
    odl::Node<T>** last;
    odl::Node<T>* finish;
    size_t size_val;
};

template <typename T>
void sort(const odl::ListIterator<T>& begin, const odl::ListIterator<T>& end, size_t n) {
    if (n < 2) return;

    auto mid = begin;
    size_t sz;
    for (sz = 0; 2*sz < n; ++sz) {
        mid++;
    }

    sort(begin, mid, sz);
    sort(mid, end, n - sz);

    List<T> s;

    auto it1 = begin;
    auto it2 = mid;

    for (; it1 != mid && it2 != end;) {
        if (*it1 > *it2) {
            s.push_back(*it2);
            ++it2;
        } else {
            s.push_back(*it1);
            ++it1;
        }
    }

    for (; it1 != mid; ++it1) {
        s.push_back(*it1);
    }

    for (; it2 != end; ++it2) {
        s.push_back(*it2);
    }

    it1 = begin;
    it2 = s.begin();
    for (; it1 != end; ++it1, ++it2) {
        *it1 = *it2;
    }

}


int main() {
    List<int> lst;
    int n;
    std::cin >> n;
    for (size_t i = 0; i != n; ++i) {
        int x;
        std::cin >> x;
        lst.push_back(x);
    }

    sort(lst.begin(), lst.end(), lst.size());
    for (auto elem : lst) {
        std::cout << elem << ' ';
    }
    std::cout << '\n';
}